import re
import spacy
from nltk.corpus import stopwords
from collections import Counter
from nltk import pos_tag
from nltk.tokenize import word_tokenize

response_a = "The {} has a gluten-free option, but it is not vegan"
response_b = "We have a selection of sides to go along with the {}, including mashed potatoes and steamed vegatables."
response_c = "{} includes habanero, so it is a bit spicy!"
response_d = "I am great, how are you?"
blank_spot = "food"

responses = [response_a, response_b, response_c, response_d]

class ChatBot:
    def __init__(self):
        self.chatProcessor = ChatProcessor()
        self.exit_commands = ("quit", "goodbye", "exit", "no")

    def make_exit(self, user_message):
        for command in self.exit_commands:
            if command in user_message:
                print("good by")
                return True

    def chat(self):
        user_message = input("Welcome, ask me any question: ")

        while not self.make_exit(user_message):
            user_message = self.respond(user_message)

    def find_intent_match(self, responses, user_message):
        bow_user_message = Counter(self.chatProcessor.preprocess(user_message))
        processed_responses = [Counter(self.chatProcessor.preprocess(response)) for response in responses]
        similarity_list = [self.chatProcessor.compareOverlap(doc, bow_user_message) for doc in processed_responses]
        response_index = similarity_list.index(max(similarity_list))
        return responses[response_index]
    
    def find_entities(self, user_message):
        # extract candidate entities
        tagged_user_message = pos_tag(self.chatProcessor.preprocess(user_message))
        message_nouns = self.chatProcessor.extractNouns(tagged_user_message)
        tokens = self.chatProcessor.word2vec(" ".join(message_nouns))
        category = self.chatProcessor.word2vec(blank_spot)
        word2vec_result = self.chatProcessor.computeSimilarity(tokens, category)
        word2vec_result.sort(key=lambda x: x[2])
        if len(word2vec_result) < 1:
            return blank_spot
        else:
            return word2vec_result[-1][0]
        
    def respond(self, user_message):
        best_response = self.find_intent_match(responses, user_message)
        entity = self.find_entities(user_message)
        print(best_response.format(entity))
        input_message = input("Do you have any other questions? ")           
        return input_message

class ChatProcessor:
    def __init__(self):
        self.word2vec = word2vec = spacy.load('en_core_web_lg')
        self.stopWords = set(stopwords.words('english'))
    
    def preprocess(self, input_sentence):
        input_sentence = input_sentence.lower()
        input_sentence = re.sub(r'[^\w\s]','',input_sentence)
        tokens = word_tokenize(input_sentence)
        input_sentence = [i for i in tokens if not i in self.stopWords]
        return input_sentence
    
    def compareOverlap(self, user_message, possible_response):
        similar_words = 0
        for token in user_message:
            if token in possible_response:
                similar_words += 1
        return similar_words
    
    def extractNouns(self, tagged_message):
        message_nouns = list()
        for token in tagged_message:
            if token[1].startswith("N"):
                message_nouns.append(token[0])
        return message_nouns
    
    def computeSimilarity(self, tokens, category):
        output_list = list()
        for token in tokens:
            output_list.append([token.text, category.text, token.similarity(category)])
        return output_list


chatbot = ChatBot()
chatbot.chat()